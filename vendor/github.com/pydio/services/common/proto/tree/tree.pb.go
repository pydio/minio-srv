// Code generated by protoc-gen-go. DO NOT EDIT.
// source: tree.proto

/*
Package tree is a generated protocol buffer package.

It is generated from these files:
	tree.proto

It has these top-level messages:
	ReadNodeRequest
	ReadNodeResponse
	ListNodesRequest
	ListNodesResponse
	CreateNodeRequest
	CreateNodeResponse
	UpdateNodeRequest
	UpdateNodeResponse
	DeleteNodeRequest
	DeleteNodeResponse
	WatchNodeRequest
	WatchNodeResponse
	SearchRequest
	SearchResponse
	CreateVersionRequest
	CreateVersionResponse
	ListVersionsRequest
	ListVersionsResponse
	HeadVersionRequest
	HeadVersionResponse
	StoreVersionRequest
	StoreVersionResponse
	Node
	ChangeLog
	Query
	GeoQuery
	GeoPoint
	NodeChangeEvent
	GetEncryptionKeyRequest
	GetEncryptionKeyResponse
*/
package tree

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	client "github.com/micro/go-micro/client"
	server "github.com/micro/go-micro/server"
	context "golang.org/x/net/context"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// ==========================================================
// * Standard Messages
// ==========================================================
type NodeType int32

const (
	NodeType_UNKNOWN    NodeType = 0
	NodeType_LEAF       NodeType = 1
	NodeType_COLLECTION NodeType = 2
)

var NodeType_name = map[int32]string{
	0: "UNKNOWN",
	1: "LEAF",
	2: "COLLECTION",
}
var NodeType_value = map[string]int32{
	"UNKNOWN":    0,
	"LEAF":       1,
	"COLLECTION": 2,
}

func (x NodeType) String() string {
	return proto.EnumName(NodeType_name, int32(x))
}
func (NodeType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type NodeChangeEvent_EventType int32

const (
	NodeChangeEvent_CREATE         NodeChangeEvent_EventType = 0
	NodeChangeEvent_READ           NodeChangeEvent_EventType = 1
	NodeChangeEvent_UPDATE_PATH    NodeChangeEvent_EventType = 2
	NodeChangeEvent_UPDATE_CONTENT NodeChangeEvent_EventType = 3
	NodeChangeEvent_UPDATE_META    NodeChangeEvent_EventType = 4
	NodeChangeEvent_DELETE         NodeChangeEvent_EventType = 5
)

var NodeChangeEvent_EventType_name = map[int32]string{
	0: "CREATE",
	1: "READ",
	2: "UPDATE_PATH",
	3: "UPDATE_CONTENT",
	4: "UPDATE_META",
	5: "DELETE",
}
var NodeChangeEvent_EventType_value = map[string]int32{
	"CREATE":         0,
	"READ":           1,
	"UPDATE_PATH":    2,
	"UPDATE_CONTENT": 3,
	"UPDATE_META":    4,
	"DELETE":         5,
}

func (x NodeChangeEvent_EventType) String() string {
	return proto.EnumName(NodeChangeEvent_EventType_name, int32(x))
}
func (NodeChangeEvent_EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{27, 0}
}

// Request / Responses Messages
type ReadNodeRequest struct {
	Node *Node `protobuf:"bytes,1,opt,name=node" json:"node,omitempty"`
}

func (m *ReadNodeRequest) Reset()                    { *m = ReadNodeRequest{} }
func (m *ReadNodeRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadNodeRequest) ProtoMessage()               {}
func (*ReadNodeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ReadNodeRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

type ReadNodeResponse struct {
	Success bool  `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
	Node    *Node `protobuf:"bytes,2,opt,name=node" json:"node,omitempty"`
}

func (m *ReadNodeResponse) Reset()                    { *m = ReadNodeResponse{} }
func (m *ReadNodeResponse) String() string            { return proto.CompactTextString(m) }
func (*ReadNodeResponse) ProtoMessage()               {}
func (*ReadNodeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ReadNodeResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *ReadNodeResponse) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

type ListNodesRequest struct {
	Node       *Node    `protobuf:"bytes,1,opt,name=node" json:"node,omitempty"`
	Recursive  bool     `protobuf:"varint,2,opt,name=recursive" json:"recursive,omitempty"`
	Ancestors  bool     `protobuf:"varint,3,opt,name=ancestors" json:"ancestors,omitempty"`
	Versions   bool     `protobuf:"varint,7,opt,name=versions" json:"versions,omitempty"`
	Limit      int64    `protobuf:"varint,4,opt,name=limit" json:"limit,omitempty"`
	Offset     int64    `protobuf:"varint,5,opt,name=offset" json:"offset,omitempty"`
	FilterType NodeType `protobuf:"varint,6,opt,name=FilterType,enum=tree.NodeType" json:"FilterType,omitempty"`
}

func (m *ListNodesRequest) Reset()                    { *m = ListNodesRequest{} }
func (m *ListNodesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListNodesRequest) ProtoMessage()               {}
func (*ListNodesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ListNodesRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *ListNodesRequest) GetRecursive() bool {
	if m != nil {
		return m.Recursive
	}
	return false
}

func (m *ListNodesRequest) GetAncestors() bool {
	if m != nil {
		return m.Ancestors
	}
	return false
}

func (m *ListNodesRequest) GetVersions() bool {
	if m != nil {
		return m.Versions
	}
	return false
}

func (m *ListNodesRequest) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListNodesRequest) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *ListNodesRequest) GetFilterType() NodeType {
	if m != nil {
		return m.FilterType
	}
	return NodeType_UNKNOWN
}

type ListNodesResponse struct {
	Node *Node `protobuf:"bytes,1,opt,name=node" json:"node,omitempty"`
}

func (m *ListNodesResponse) Reset()                    { *m = ListNodesResponse{} }
func (m *ListNodesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListNodesResponse) ProtoMessage()               {}
func (*ListNodesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ListNodesResponse) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

// Request / Responses Messages
type CreateNodeRequest struct {
	Node           *Node `protobuf:"bytes,1,opt,name=node" json:"node,omitempty"`
	UpdateIfExists bool  `protobuf:"varint,2,opt,name=updateIfExists" json:"updateIfExists,omitempty"`
}

func (m *CreateNodeRequest) Reset()                    { *m = CreateNodeRequest{} }
func (m *CreateNodeRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateNodeRequest) ProtoMessage()               {}
func (*CreateNodeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *CreateNodeRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *CreateNodeRequest) GetUpdateIfExists() bool {
	if m != nil {
		return m.UpdateIfExists
	}
	return false
}

type CreateNodeResponse struct {
	Success bool  `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
	Node    *Node `protobuf:"bytes,2,opt,name=node" json:"node,omitempty"`
}

func (m *CreateNodeResponse) Reset()                    { *m = CreateNodeResponse{} }
func (m *CreateNodeResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateNodeResponse) ProtoMessage()               {}
func (*CreateNodeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *CreateNodeResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *CreateNodeResponse) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

type UpdateNodeRequest struct {
	From *Node `protobuf:"bytes,1,opt,name=from" json:"from,omitempty"`
	To   *Node `protobuf:"bytes,2,opt,name=to" json:"to,omitempty"`
}

func (m *UpdateNodeRequest) Reset()                    { *m = UpdateNodeRequest{} }
func (m *UpdateNodeRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateNodeRequest) ProtoMessage()               {}
func (*UpdateNodeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *UpdateNodeRequest) GetFrom() *Node {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *UpdateNodeRequest) GetTo() *Node {
	if m != nil {
		return m.To
	}
	return nil
}

type UpdateNodeResponse struct {
	Success bool  `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
	Node    *Node `protobuf:"bytes,2,opt,name=node" json:"node,omitempty"`
}

func (m *UpdateNodeResponse) Reset()                    { *m = UpdateNodeResponse{} }
func (m *UpdateNodeResponse) String() string            { return proto.CompactTextString(m) }
func (*UpdateNodeResponse) ProtoMessage()               {}
func (*UpdateNodeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *UpdateNodeResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *UpdateNodeResponse) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

type DeleteNodeRequest struct {
	Node *Node `protobuf:"bytes,1,opt,name=node" json:"node,omitempty"`
}

func (m *DeleteNodeRequest) Reset()                    { *m = DeleteNodeRequest{} }
func (m *DeleteNodeRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteNodeRequest) ProtoMessage()               {}
func (*DeleteNodeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *DeleteNodeRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

type DeleteNodeResponse struct {
	Success bool `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
}

func (m *DeleteNodeResponse) Reset()                    { *m = DeleteNodeResponse{} }
func (m *DeleteNodeResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteNodeResponse) ProtoMessage()               {}
func (*DeleteNodeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *DeleteNodeResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

// Request / Responses Messages
type WatchNodeRequest struct {
	Node *Node `protobuf:"bytes,1,opt,name=node" json:"node,omitempty"`
}

func (m *WatchNodeRequest) Reset()                    { *m = WatchNodeRequest{} }
func (m *WatchNodeRequest) String() string            { return proto.CompactTextString(m) }
func (*WatchNodeRequest) ProtoMessage()               {}
func (*WatchNodeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *WatchNodeRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

type WatchNodeResponse struct {
	Node *Node `protobuf:"bytes,1,opt,name=node" json:"node,omitempty"`
}

func (m *WatchNodeResponse) Reset()                    { *m = WatchNodeResponse{} }
func (m *WatchNodeResponse) String() string            { return proto.CompactTextString(m) }
func (*WatchNodeResponse) ProtoMessage()               {}
func (*WatchNodeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *WatchNodeResponse) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

type SearchRequest struct {
	// The query object
	Query *Query `protobuf:"bytes,1,opt,name=Query" json:"Query,omitempty"`
	// Limit the number of results
	Size int32 `protobuf:"varint,2,opt,name=Size" json:"Size,omitempty"`
	// Start at given position
	From int32 `protobuf:"varint,3,opt,name=From" json:"From,omitempty"`
	// Load node details
	Details bool `protobuf:"varint,4,opt,name=Details" json:"Details,omitempty"`
	// Facet search
	Facet string `protobuf:"bytes,5,opt,name=Facet" json:"Facet,omitempty"`
}

func (m *SearchRequest) Reset()                    { *m = SearchRequest{} }
func (m *SearchRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchRequest) ProtoMessage()               {}
func (*SearchRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *SearchRequest) GetQuery() *Query {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *SearchRequest) GetSize() int32 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *SearchRequest) GetFrom() int32 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *SearchRequest) GetDetails() bool {
	if m != nil {
		return m.Details
	}
	return false
}

func (m *SearchRequest) GetFacet() string {
	if m != nil {
		return m.Facet
	}
	return ""
}

type SearchResponse struct {
	Node *Node `protobuf:"bytes,1,opt,name=node" json:"node,omitempty"`
}

func (m *SearchResponse) Reset()                    { *m = SearchResponse{} }
func (m *SearchResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchResponse) ProtoMessage()               {}
func (*SearchResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *SearchResponse) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

type CreateVersionRequest struct {
	Node *Node `protobuf:"bytes,1,opt,name=node" json:"node,omitempty"`
}

func (m *CreateVersionRequest) Reset()                    { *m = CreateVersionRequest{} }
func (m *CreateVersionRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateVersionRequest) ProtoMessage()               {}
func (*CreateVersionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *CreateVersionRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

type CreateVersionResponse struct {
	Version *ChangeLog `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
}

func (m *CreateVersionResponse) Reset()                    { *m = CreateVersionResponse{} }
func (m *CreateVersionResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateVersionResponse) ProtoMessage()               {}
func (*CreateVersionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *CreateVersionResponse) GetVersion() *ChangeLog {
	if m != nil {
		return m.Version
	}
	return nil
}

type ListVersionsRequest struct {
	Node *Node `protobuf:"bytes,1,opt,name=node" json:"node,omitempty"`
}

func (m *ListVersionsRequest) Reset()                    { *m = ListVersionsRequest{} }
func (m *ListVersionsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListVersionsRequest) ProtoMessage()               {}
func (*ListVersionsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *ListVersionsRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

type ListVersionsResponse struct {
	Version *ChangeLog `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
}

func (m *ListVersionsResponse) Reset()                    { *m = ListVersionsResponse{} }
func (m *ListVersionsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListVersionsResponse) ProtoMessage()               {}
func (*ListVersionsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *ListVersionsResponse) GetVersion() *ChangeLog {
	if m != nil {
		return m.Version
	}
	return nil
}

type HeadVersionRequest struct {
	Node      *Node  `protobuf:"bytes,1,opt,name=node" json:"node,omitempty"`
	VersionId string `protobuf:"bytes,2,opt,name=VersionId" json:"VersionId,omitempty"`
}

func (m *HeadVersionRequest) Reset()                    { *m = HeadVersionRequest{} }
func (m *HeadVersionRequest) String() string            { return proto.CompactTextString(m) }
func (*HeadVersionRequest) ProtoMessage()               {}
func (*HeadVersionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *HeadVersionRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *HeadVersionRequest) GetVersionId() string {
	if m != nil {
		return m.VersionId
	}
	return ""
}

type HeadVersionResponse struct {
	Version *ChangeLog `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
}

func (m *HeadVersionResponse) Reset()                    { *m = HeadVersionResponse{} }
func (m *HeadVersionResponse) String() string            { return proto.CompactTextString(m) }
func (*HeadVersionResponse) ProtoMessage()               {}
func (*HeadVersionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *HeadVersionResponse) GetVersion() *ChangeLog {
	if m != nil {
		return m.Version
	}
	return nil
}

type StoreVersionRequest struct {
	Node    *Node      `protobuf:"bytes,1,opt,name=node" json:"node,omitempty"`
	Version *ChangeLog `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
}

func (m *StoreVersionRequest) Reset()                    { *m = StoreVersionRequest{} }
func (m *StoreVersionRequest) String() string            { return proto.CompactTextString(m) }
func (*StoreVersionRequest) ProtoMessage()               {}
func (*StoreVersionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *StoreVersionRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *StoreVersionRequest) GetVersion() *ChangeLog {
	if m != nil {
		return m.Version
	}
	return nil
}

type StoreVersionResponse struct {
	Success bool `protobuf:"varint,1,opt,name=Success" json:"Success,omitempty"`
}

func (m *StoreVersionResponse) Reset()                    { *m = StoreVersionResponse{} }
func (m *StoreVersionResponse) String() string            { return proto.CompactTextString(m) }
func (*StoreVersionResponse) ProtoMessage()               {}
func (*StoreVersionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *StoreVersionResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type Node struct {
	// ------------------------------------
	// Core identification of the node
	// ------------------------------------
	Uuid string   `protobuf:"bytes,1,opt,name=Uuid" json:"Uuid,omitempty"`
	Path string   `protobuf:"bytes,2,opt,name=Path" json:"Path,omitempty"`
	Type NodeType `protobuf:"varint,3,opt,name=type,enum=tree.NodeType" json:"type,omitempty"`
	// Size of the file, or cumulated size of folder
	Size int64 `protobuf:"varint,4,opt,name=Size" json:"Size,omitempty"`
	// Last modification Timestamp
	MTime int64 `protobuf:"varint,5,opt,name=MTime" json:"MTime,omitempty"`
	// Permission mode, like 0777
	Mode int32 `protobuf:"varint,6,opt,name=Mode" json:"Mode,omitempty"`
	// Hash of the content if node is a LEAF, Uuid or
	Etag string `protobuf:"bytes,7,opt,name=Etag" json:"Etag,omitempty"`
	// List of successive commits
	Commits []*ChangeLog `protobuf:"bytes,9,rep,name=Commits" json:"Commits,omitempty"`
	// ------------------------------------
	// Then a free K => V representation of any kind of metadata
	// ------------------------------------
	MetaStore map[string]string `protobuf:"bytes,8,rep,name=MetaStore" json:"MetaStore,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *Node) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *Node) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Node) GetType() NodeType {
	if m != nil {
		return m.Type
	}
	return NodeType_UNKNOWN
}

func (m *Node) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *Node) GetMTime() int64 {
	if m != nil {
		return m.MTime
	}
	return 0
}

func (m *Node) GetMode() int32 {
	if m != nil {
		return m.Mode
	}
	return 0
}

func (m *Node) GetEtag() string {
	if m != nil {
		return m.Etag
	}
	return ""
}

func (m *Node) GetCommits() []*ChangeLog {
	if m != nil {
		return m.Commits
	}
	return nil
}

func (m *Node) GetMetaStore() map[string]string {
	if m != nil {
		return m.MetaStore
	}
	return nil
}

type ChangeLog struct {
	// Unique commit ID
	Uuid string `protobuf:"bytes,1,opt,name=Uuid" json:"Uuid,omitempty"`
	// Human-readable description of what happened
	Description string `protobuf:"bytes,2,opt,name=Description" json:"Description,omitempty"`
	// Unix Timestamp
	MTime int64 `protobuf:"varint,3,opt,name=MTime" json:"MTime,omitempty"`
	// Content Size at that moment
	Size int64 `protobuf:"varint,4,opt,name=Size" json:"Size,omitempty"`
	// Arbitrary additional data
	Data []byte `protobuf:"bytes,5,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *ChangeLog) Reset()                    { *m = ChangeLog{} }
func (m *ChangeLog) String() string            { return proto.CompactTextString(m) }
func (*ChangeLog) ProtoMessage()               {}
func (*ChangeLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *ChangeLog) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ChangeLog) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ChangeLog) GetMTime() int64 {
	if m != nil {
		return m.MTime
	}
	return 0
}

func (m *ChangeLog) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *ChangeLog) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Search Queries
type Query struct {
	// Limit to a given subtree
	PathPrefix []string `protobuf:"bytes,1,rep,name=PathPrefix" json:"PathPrefix,omitempty"`
	// Range for size
	MinSize int64 `protobuf:"varint,2,opt,name=MinSize" json:"MinSize,omitempty"`
	MaxSize int64 `protobuf:"varint,3,opt,name=MaxSize" json:"MaxSize,omitempty"`
	// Range for date
	MinDate int64 `protobuf:"varint,4,opt,name=MinDate" json:"MinDate,omitempty"`
	MaxDate int64 `protobuf:"varint,5,opt,name=MaxDate" json:"MaxDate,omitempty"`
	// Limit to a given node type
	Type NodeType `protobuf:"varint,6,opt,name=Type,enum=tree.NodeType" json:"Type,omitempty"`
	// Search in filename
	FileName string `protobuf:"bytes,7,opt,name=FileName" json:"FileName,omitempty"`
	// Search in content
	Content string `protobuf:"bytes,8,opt,name=Content" json:"Content,omitempty"`
	// Free Query String (for metadata)
	FreeString string `protobuf:"bytes,9,opt,name=FreeString" json:"FreeString,omitempty"`
	// Search files by extension
	Extension string `protobuf:"bytes,10,opt,name=Extension" json:"Extension,omitempty"`
	// Search geographically
	GeoQuery *GeoQuery `protobuf:"bytes,11,opt,name=GeoQuery" json:"GeoQuery,omitempty"`
}

func (m *Query) Reset()                    { *m = Query{} }
func (m *Query) String() string            { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()               {}
func (*Query) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *Query) GetPathPrefix() []string {
	if m != nil {
		return m.PathPrefix
	}
	return nil
}

func (m *Query) GetMinSize() int64 {
	if m != nil {
		return m.MinSize
	}
	return 0
}

func (m *Query) GetMaxSize() int64 {
	if m != nil {
		return m.MaxSize
	}
	return 0
}

func (m *Query) GetMinDate() int64 {
	if m != nil {
		return m.MinDate
	}
	return 0
}

func (m *Query) GetMaxDate() int64 {
	if m != nil {
		return m.MaxDate
	}
	return 0
}

func (m *Query) GetType() NodeType {
	if m != nil {
		return m.Type
	}
	return NodeType_UNKNOWN
}

func (m *Query) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *Query) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *Query) GetFreeString() string {
	if m != nil {
		return m.FreeString
	}
	return ""
}

func (m *Query) GetExtension() string {
	if m != nil {
		return m.Extension
	}
	return ""
}

func (m *Query) GetGeoQuery() *GeoQuery {
	if m != nil {
		return m.GeoQuery
	}
	return nil
}

type GeoQuery struct {
	// Either use a center point and a distance
	Center *GeoPoint `protobuf:"bytes,1,opt,name=Center" json:"Center,omitempty"`
	// Example formats supported:
	// "5in" "5inch" "7yd" "7yards" "9ft" "9feet" "11km" "11kilometers"
	// "3nm" "3nauticalmiles" "13mm" "13millimeters" "15cm" "15centimeters"
	// "17mi" "17miles" "19m" "19meters"
	// If the unit cannot be determined, the entire string is parsed and the
	// unit of meters is assumed.
	Distance string `protobuf:"bytes,2,opt,name=Distance" json:"Distance,omitempty"`
	// Or use a bounding box with TopLeft and BottomRight points
	TopLeft     *GeoPoint `protobuf:"bytes,3,opt,name=TopLeft" json:"TopLeft,omitempty"`
	BottomRight *GeoPoint `protobuf:"bytes,4,opt,name=BottomRight" json:"BottomRight,omitempty"`
}

func (m *GeoQuery) Reset()                    { *m = GeoQuery{} }
func (m *GeoQuery) String() string            { return proto.CompactTextString(m) }
func (*GeoQuery) ProtoMessage()               {}
func (*GeoQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *GeoQuery) GetCenter() *GeoPoint {
	if m != nil {
		return m.Center
	}
	return nil
}

func (m *GeoQuery) GetDistance() string {
	if m != nil {
		return m.Distance
	}
	return ""
}

func (m *GeoQuery) GetTopLeft() *GeoPoint {
	if m != nil {
		return m.TopLeft
	}
	return nil
}

func (m *GeoQuery) GetBottomRight() *GeoPoint {
	if m != nil {
		return m.BottomRight
	}
	return nil
}

type GeoPoint struct {
	Lat float64 `protobuf:"fixed64,1,opt,name=lat" json:"lat,omitempty"`
	Lon float64 `protobuf:"fixed64,2,opt,name=lon" json:"lon,omitempty"`
}

func (m *GeoPoint) Reset()                    { *m = GeoPoint{} }
func (m *GeoPoint) String() string            { return proto.CompactTextString(m) }
func (*GeoPoint) ProtoMessage()               {}
func (*GeoPoint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *GeoPoint) GetLat() float64 {
	if m != nil {
		return m.Lat
	}
	return 0
}

func (m *GeoPoint) GetLon() float64 {
	if m != nil {
		return m.Lon
	}
	return 0
}

type NodeChangeEvent struct {
	Type   NodeChangeEvent_EventType `protobuf:"varint,1,opt,name=Type,enum=tree.NodeChangeEvent_EventType" json:"Type,omitempty"`
	Source *Node                     `protobuf:"bytes,2,opt,name=Source" json:"Source,omitempty"`
	Target *Node                     `protobuf:"bytes,3,opt,name=Target" json:"Target,omitempty"`
}

func (m *NodeChangeEvent) Reset()                    { *m = NodeChangeEvent{} }
func (m *NodeChangeEvent) String() string            { return proto.CompactTextString(m) }
func (*NodeChangeEvent) ProtoMessage()               {}
func (*NodeChangeEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *NodeChangeEvent) GetType() NodeChangeEvent_EventType {
	if m != nil {
		return m.Type
	}
	return NodeChangeEvent_CREATE
}

func (m *NodeChangeEvent) GetSource() *Node {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *NodeChangeEvent) GetTarget() *Node {
	if m != nil {
		return m.Target
	}
	return nil
}

type GetEncryptionKeyRequest struct {
	User     string `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
	Node     *Node  `protobuf:"bytes,3,opt,name=node" json:"node,omitempty"`
	Create   bool   `protobuf:"varint,5,opt,name=create" json:"create,omitempty"`
}

func (m *GetEncryptionKeyRequest) Reset()                    { *m = GetEncryptionKeyRequest{} }
func (m *GetEncryptionKeyRequest) String() string            { return proto.CompactTextString(m) }
func (*GetEncryptionKeyRequest) ProtoMessage()               {}
func (*GetEncryptionKeyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *GetEncryptionKeyRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *GetEncryptionKeyRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *GetEncryptionKeyRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *GetEncryptionKeyRequest) GetCreate() bool {
	if m != nil {
		return m.Create
	}
	return false
}

type GetEncryptionKeyResponse struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *GetEncryptionKeyResponse) Reset()                    { *m = GetEncryptionKeyResponse{} }
func (m *GetEncryptionKeyResponse) String() string            { return proto.CompactTextString(m) }
func (*GetEncryptionKeyResponse) ProtoMessage()               {}
func (*GetEncryptionKeyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *GetEncryptionKeyResponse) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func init() {
	proto.RegisterType((*ReadNodeRequest)(nil), "tree.ReadNodeRequest")
	proto.RegisterType((*ReadNodeResponse)(nil), "tree.ReadNodeResponse")
	proto.RegisterType((*ListNodesRequest)(nil), "tree.ListNodesRequest")
	proto.RegisterType((*ListNodesResponse)(nil), "tree.ListNodesResponse")
	proto.RegisterType((*CreateNodeRequest)(nil), "tree.CreateNodeRequest")
	proto.RegisterType((*CreateNodeResponse)(nil), "tree.CreateNodeResponse")
	proto.RegisterType((*UpdateNodeRequest)(nil), "tree.UpdateNodeRequest")
	proto.RegisterType((*UpdateNodeResponse)(nil), "tree.UpdateNodeResponse")
	proto.RegisterType((*DeleteNodeRequest)(nil), "tree.DeleteNodeRequest")
	proto.RegisterType((*DeleteNodeResponse)(nil), "tree.DeleteNodeResponse")
	proto.RegisterType((*WatchNodeRequest)(nil), "tree.WatchNodeRequest")
	proto.RegisterType((*WatchNodeResponse)(nil), "tree.WatchNodeResponse")
	proto.RegisterType((*SearchRequest)(nil), "tree.SearchRequest")
	proto.RegisterType((*SearchResponse)(nil), "tree.SearchResponse")
	proto.RegisterType((*CreateVersionRequest)(nil), "tree.CreateVersionRequest")
	proto.RegisterType((*CreateVersionResponse)(nil), "tree.CreateVersionResponse")
	proto.RegisterType((*ListVersionsRequest)(nil), "tree.ListVersionsRequest")
	proto.RegisterType((*ListVersionsResponse)(nil), "tree.ListVersionsResponse")
	proto.RegisterType((*HeadVersionRequest)(nil), "tree.HeadVersionRequest")
	proto.RegisterType((*HeadVersionResponse)(nil), "tree.HeadVersionResponse")
	proto.RegisterType((*StoreVersionRequest)(nil), "tree.StoreVersionRequest")
	proto.RegisterType((*StoreVersionResponse)(nil), "tree.StoreVersionResponse")
	proto.RegisterType((*Node)(nil), "tree.Node")
	proto.RegisterType((*ChangeLog)(nil), "tree.ChangeLog")
	proto.RegisterType((*Query)(nil), "tree.Query")
	proto.RegisterType((*GeoQuery)(nil), "tree.GeoQuery")
	proto.RegisterType((*GeoPoint)(nil), "tree.GeoPoint")
	proto.RegisterType((*NodeChangeEvent)(nil), "tree.NodeChangeEvent")
	proto.RegisterType((*GetEncryptionKeyRequest)(nil), "tree.GetEncryptionKeyRequest")
	proto.RegisterType((*GetEncryptionKeyResponse)(nil), "tree.GetEncryptionKeyResponse")
	proto.RegisterEnum("tree.NodeType", NodeType_name, NodeType_value)
	proto.RegisterEnum("tree.NodeChangeEvent_EventType", NodeChangeEvent_EventType_name, NodeChangeEvent_EventType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ client.Option
var _ server.Option

// Client API for NodeProvider service

type NodeProviderClient interface {
	ReadNode(ctx context.Context, in *ReadNodeRequest, opts ...client.CallOption) (*ReadNodeResponse, error)
	ListNodes(ctx context.Context, in *ListNodesRequest, opts ...client.CallOption) (NodeProvider_ListNodesClient, error)
}

type nodeProviderClient struct {
	c           client.Client
	serviceName string
}

func NewNodeProviderClient(serviceName string, c client.Client) NodeProviderClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeProviderClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *nodeProviderClient) ReadNode(ctx context.Context, in *ReadNodeRequest, opts ...client.CallOption) (*ReadNodeResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeProvider.ReadNode", in)
	out := new(ReadNodeResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeProviderClient) ListNodes(ctx context.Context, in *ListNodesRequest, opts ...client.CallOption) (NodeProvider_ListNodesClient, error) {
	req := c.c.NewRequest(c.serviceName, "NodeProvider.ListNodes", &ListNodesRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	if err := stream.Send(in); err != nil {
		return nil, err
	}
	return &nodeProviderListNodesClient{stream}, nil
}

type NodeProvider_ListNodesClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Recv() (*ListNodesResponse, error)
}

type nodeProviderListNodesClient struct {
	stream client.Streamer
}

func (x *nodeProviderListNodesClient) Close() error {
	return x.stream.Close()
}

func (x *nodeProviderListNodesClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeProviderListNodesClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeProviderListNodesClient) Recv() (*ListNodesResponse, error) {
	m := new(ListNodesResponse)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for NodeProvider service

type NodeProviderHandler interface {
	ReadNode(context.Context, *ReadNodeRequest, *ReadNodeResponse) error
	ListNodes(context.Context, *ListNodesRequest, NodeProvider_ListNodesStream) error
}

func RegisterNodeProviderHandler(s server.Server, hdlr NodeProviderHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeProvider{hdlr}, opts...))
}

type NodeProvider struct {
	NodeProviderHandler
}

func (h *NodeProvider) ReadNode(ctx context.Context, in *ReadNodeRequest, out *ReadNodeResponse) error {
	return h.NodeProviderHandler.ReadNode(ctx, in, out)
}

func (h *NodeProvider) ListNodes(ctx context.Context, stream server.Streamer) error {
	m := new(ListNodesRequest)
	if err := stream.Recv(m); err != nil {
		return err
	}
	return h.NodeProviderHandler.ListNodes(ctx, m, &nodeProviderListNodesStream{stream})
}

type NodeProvider_ListNodesStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*ListNodesResponse) error
}

type nodeProviderListNodesStream struct {
	stream server.Streamer
}

func (x *nodeProviderListNodesStream) Close() error {
	return x.stream.Close()
}

func (x *nodeProviderListNodesStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeProviderListNodesStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeProviderListNodesStream) Send(m *ListNodesResponse) error {
	return x.stream.Send(m)
}

// Client API for NodeProviderStreamer service

type NodeProviderStreamerClient interface {
	ReadNodeStream(ctx context.Context, opts ...client.CallOption) (NodeProviderStreamer_ReadNodeStreamClient, error)
}

type nodeProviderStreamerClient struct {
	c           client.Client
	serviceName string
}

func NewNodeProviderStreamerClient(serviceName string, c client.Client) NodeProviderStreamerClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeProviderStreamerClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *nodeProviderStreamerClient) ReadNodeStream(ctx context.Context, opts ...client.CallOption) (NodeProviderStreamer_ReadNodeStreamClient, error) {
	req := c.c.NewRequest(c.serviceName, "NodeProviderStreamer.ReadNodeStream", &ReadNodeRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return &nodeProviderStreamerReadNodeStreamClient{stream}, nil
}

type NodeProviderStreamer_ReadNodeStreamClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*ReadNodeRequest) error
	Recv() (*ReadNodeResponse, error)
}

type nodeProviderStreamerReadNodeStreamClient struct {
	stream client.Streamer
}

func (x *nodeProviderStreamerReadNodeStreamClient) Close() error {
	return x.stream.Close()
}

func (x *nodeProviderStreamerReadNodeStreamClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeProviderStreamerReadNodeStreamClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeProviderStreamerReadNodeStreamClient) Send(m *ReadNodeRequest) error {
	return x.stream.Send(m)
}

func (x *nodeProviderStreamerReadNodeStreamClient) Recv() (*ReadNodeResponse, error) {
	m := new(ReadNodeResponse)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for NodeProviderStreamer service

type NodeProviderStreamerHandler interface {
	ReadNodeStream(context.Context, NodeProviderStreamer_ReadNodeStreamStream) error
}

func RegisterNodeProviderStreamerHandler(s server.Server, hdlr NodeProviderStreamerHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeProviderStreamer{hdlr}, opts...))
}

type NodeProviderStreamer struct {
	NodeProviderStreamerHandler
}

func (h *NodeProviderStreamer) ReadNodeStream(ctx context.Context, stream server.Streamer) error {
	return h.NodeProviderStreamerHandler.ReadNodeStream(ctx, &nodeProviderStreamerReadNodeStreamStream{stream})
}

type NodeProviderStreamer_ReadNodeStreamStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*ReadNodeResponse) error
	Recv() (*ReadNodeRequest, error)
}

type nodeProviderStreamerReadNodeStreamStream struct {
	stream server.Streamer
}

func (x *nodeProviderStreamerReadNodeStreamStream) Close() error {
	return x.stream.Close()
}

func (x *nodeProviderStreamerReadNodeStreamStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeProviderStreamerReadNodeStreamStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeProviderStreamerReadNodeStreamStream) Send(m *ReadNodeResponse) error {
	return x.stream.Send(m)
}

func (x *nodeProviderStreamerReadNodeStreamStream) Recv() (*ReadNodeRequest, error) {
	m := new(ReadNodeRequest)
	if err := x.stream.Recv(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Client API for NodeReceiver service

type NodeReceiverClient interface {
	CreateNode(ctx context.Context, in *CreateNodeRequest, opts ...client.CallOption) (*CreateNodeResponse, error)
	UpdateNode(ctx context.Context, in *UpdateNodeRequest, opts ...client.CallOption) (*UpdateNodeResponse, error)
	DeleteNode(ctx context.Context, in *DeleteNodeRequest, opts ...client.CallOption) (*DeleteNodeResponse, error)
}

type nodeReceiverClient struct {
	c           client.Client
	serviceName string
}

func NewNodeReceiverClient(serviceName string, c client.Client) NodeReceiverClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeReceiverClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *nodeReceiverClient) CreateNode(ctx context.Context, in *CreateNodeRequest, opts ...client.CallOption) (*CreateNodeResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeReceiver.CreateNode", in)
	out := new(CreateNodeResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeReceiverClient) UpdateNode(ctx context.Context, in *UpdateNodeRequest, opts ...client.CallOption) (*UpdateNodeResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeReceiver.UpdateNode", in)
	out := new(UpdateNodeResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeReceiverClient) DeleteNode(ctx context.Context, in *DeleteNodeRequest, opts ...client.CallOption) (*DeleteNodeResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeReceiver.DeleteNode", in)
	out := new(DeleteNodeResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for NodeReceiver service

type NodeReceiverHandler interface {
	CreateNode(context.Context, *CreateNodeRequest, *CreateNodeResponse) error
	UpdateNode(context.Context, *UpdateNodeRequest, *UpdateNodeResponse) error
	DeleteNode(context.Context, *DeleteNodeRequest, *DeleteNodeResponse) error
}

func RegisterNodeReceiverHandler(s server.Server, hdlr NodeReceiverHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeReceiver{hdlr}, opts...))
}

type NodeReceiver struct {
	NodeReceiverHandler
}

func (h *NodeReceiver) CreateNode(ctx context.Context, in *CreateNodeRequest, out *CreateNodeResponse) error {
	return h.NodeReceiverHandler.CreateNode(ctx, in, out)
}

func (h *NodeReceiver) UpdateNode(ctx context.Context, in *UpdateNodeRequest, out *UpdateNodeResponse) error {
	return h.NodeReceiverHandler.UpdateNode(ctx, in, out)
}

func (h *NodeReceiver) DeleteNode(ctx context.Context, in *DeleteNodeRequest, out *DeleteNodeResponse) error {
	return h.NodeReceiverHandler.DeleteNode(ctx, in, out)
}

// Client API for NodeEventsProvider service

type NodeEventsProviderClient interface {
	WatchNode(ctx context.Context, in *WatchNodeRequest, opts ...client.CallOption) (NodeEventsProvider_WatchNodeClient, error)
}

type nodeEventsProviderClient struct {
	c           client.Client
	serviceName string
}

func NewNodeEventsProviderClient(serviceName string, c client.Client) NodeEventsProviderClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeEventsProviderClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *nodeEventsProviderClient) WatchNode(ctx context.Context, in *WatchNodeRequest, opts ...client.CallOption) (NodeEventsProvider_WatchNodeClient, error) {
	req := c.c.NewRequest(c.serviceName, "NodeEventsProvider.WatchNode", &WatchNodeRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	if err := stream.Send(in); err != nil {
		return nil, err
	}
	return &nodeEventsProviderWatchNodeClient{stream}, nil
}

type NodeEventsProvider_WatchNodeClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Recv() (*WatchNodeResponse, error)
}

type nodeEventsProviderWatchNodeClient struct {
	stream client.Streamer
}

func (x *nodeEventsProviderWatchNodeClient) Close() error {
	return x.stream.Close()
}

func (x *nodeEventsProviderWatchNodeClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeEventsProviderWatchNodeClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeEventsProviderWatchNodeClient) Recv() (*WatchNodeResponse, error) {
	m := new(WatchNodeResponse)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for NodeEventsProvider service

type NodeEventsProviderHandler interface {
	WatchNode(context.Context, *WatchNodeRequest, NodeEventsProvider_WatchNodeStream) error
}

func RegisterNodeEventsProviderHandler(s server.Server, hdlr NodeEventsProviderHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeEventsProvider{hdlr}, opts...))
}

type NodeEventsProvider struct {
	NodeEventsProviderHandler
}

func (h *NodeEventsProvider) WatchNode(ctx context.Context, stream server.Streamer) error {
	m := new(WatchNodeRequest)
	if err := stream.Recv(m); err != nil {
		return err
	}
	return h.NodeEventsProviderHandler.WatchNode(ctx, m, &nodeEventsProviderWatchNodeStream{stream})
}

type NodeEventsProvider_WatchNodeStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*WatchNodeResponse) error
}

type nodeEventsProviderWatchNodeStream struct {
	stream server.Streamer
}

func (x *nodeEventsProviderWatchNodeStream) Close() error {
	return x.stream.Close()
}

func (x *nodeEventsProviderWatchNodeStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeEventsProviderWatchNodeStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeEventsProviderWatchNodeStream) Send(m *WatchNodeResponse) error {
	return x.stream.Send(m)
}

// Client API for Searcher service

type SearcherClient interface {
	Search(ctx context.Context, in *SearchRequest, opts ...client.CallOption) (Searcher_SearchClient, error)
}

type searcherClient struct {
	c           client.Client
	serviceName string
}

func NewSearcherClient(serviceName string, c client.Client) SearcherClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &searcherClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *searcherClient) Search(ctx context.Context, in *SearchRequest, opts ...client.CallOption) (Searcher_SearchClient, error) {
	req := c.c.NewRequest(c.serviceName, "Searcher.Search", &SearchRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	if err := stream.Send(in); err != nil {
		return nil, err
	}
	return &searcherSearchClient{stream}, nil
}

type Searcher_SearchClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Recv() (*SearchResponse, error)
}

type searcherSearchClient struct {
	stream client.Streamer
}

func (x *searcherSearchClient) Close() error {
	return x.stream.Close()
}

func (x *searcherSearchClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *searcherSearchClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *searcherSearchClient) Recv() (*SearchResponse, error) {
	m := new(SearchResponse)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Searcher service

type SearcherHandler interface {
	Search(context.Context, *SearchRequest, Searcher_SearchStream) error
}

func RegisterSearcherHandler(s server.Server, hdlr SearcherHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&Searcher{hdlr}, opts...))
}

type Searcher struct {
	SearcherHandler
}

func (h *Searcher) Search(ctx context.Context, stream server.Streamer) error {
	m := new(SearchRequest)
	if err := stream.Recv(m); err != nil {
		return err
	}
	return h.SearcherHandler.Search(ctx, m, &searcherSearchStream{stream})
}

type Searcher_SearchStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*SearchResponse) error
}

type searcherSearchStream struct {
	stream server.Streamer
}

func (x *searcherSearchStream) Close() error {
	return x.stream.Close()
}

func (x *searcherSearchStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *searcherSearchStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *searcherSearchStream) Send(m *SearchResponse) error {
	return x.stream.Send(m)
}

// Client API for NodeContentReader service

type NodeContentReaderClient interface {
}

type nodeContentReaderClient struct {
	c           client.Client
	serviceName string
}

func NewNodeContentReaderClient(serviceName string, c client.Client) NodeContentReaderClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeContentReaderClient{
		c:           c,
		serviceName: serviceName,
	}
}

// Server API for NodeContentReader service

type NodeContentReaderHandler interface {
}

func RegisterNodeContentReaderHandler(s server.Server, hdlr NodeContentReaderHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeContentReader{hdlr}, opts...))
}

type NodeContentReader struct {
	NodeContentReaderHandler
}

// Client API for NodeContentWriter service

type NodeContentWriterClient interface {
}

type nodeContentWriterClient struct {
	c           client.Client
	serviceName string
}

func NewNodeContentWriterClient(serviceName string, c client.Client) NodeContentWriterClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeContentWriterClient{
		c:           c,
		serviceName: serviceName,
	}
}

// Server API for NodeContentWriter service

type NodeContentWriterHandler interface {
}

func RegisterNodeContentWriterHandler(s server.Server, hdlr NodeContentWriterHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeContentWriter{hdlr}, opts...))
}

type NodeContentWriter struct {
	NodeContentWriterHandler
}

// Client API for NodeVersioner service

type NodeVersionerClient interface {
	CreateVersion(ctx context.Context, in *CreateVersionRequest, opts ...client.CallOption) (*CreateVersionResponse, error)
	StoreVersion(ctx context.Context, in *StoreVersionRequest, opts ...client.CallOption) (*StoreVersionResponse, error)
	ListVersions(ctx context.Context, in *ListVersionsRequest, opts ...client.CallOption) (NodeVersioner_ListVersionsClient, error)
	HeadVersion(ctx context.Context, in *HeadVersionRequest, opts ...client.CallOption) (*HeadVersionResponse, error)
}

type nodeVersionerClient struct {
	c           client.Client
	serviceName string
}

func NewNodeVersionerClient(serviceName string, c client.Client) NodeVersionerClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeVersionerClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *nodeVersionerClient) CreateVersion(ctx context.Context, in *CreateVersionRequest, opts ...client.CallOption) (*CreateVersionResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeVersioner.CreateVersion", in)
	out := new(CreateVersionResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeVersionerClient) StoreVersion(ctx context.Context, in *StoreVersionRequest, opts ...client.CallOption) (*StoreVersionResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeVersioner.StoreVersion", in)
	out := new(StoreVersionResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeVersionerClient) ListVersions(ctx context.Context, in *ListVersionsRequest, opts ...client.CallOption) (NodeVersioner_ListVersionsClient, error) {
	req := c.c.NewRequest(c.serviceName, "NodeVersioner.ListVersions", &ListVersionsRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	if err := stream.Send(in); err != nil {
		return nil, err
	}
	return &nodeVersionerListVersionsClient{stream}, nil
}

type NodeVersioner_ListVersionsClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Recv() (*ListVersionsResponse, error)
}

type nodeVersionerListVersionsClient struct {
	stream client.Streamer
}

func (x *nodeVersionerListVersionsClient) Close() error {
	return x.stream.Close()
}

func (x *nodeVersionerListVersionsClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeVersionerListVersionsClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeVersionerListVersionsClient) Recv() (*ListVersionsResponse, error) {
	m := new(ListVersionsResponse)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeVersionerClient) HeadVersion(ctx context.Context, in *HeadVersionRequest, opts ...client.CallOption) (*HeadVersionResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeVersioner.HeadVersion", in)
	out := new(HeadVersionResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for NodeVersioner service

type NodeVersionerHandler interface {
	CreateVersion(context.Context, *CreateVersionRequest, *CreateVersionResponse) error
	StoreVersion(context.Context, *StoreVersionRequest, *StoreVersionResponse) error
	ListVersions(context.Context, *ListVersionsRequest, NodeVersioner_ListVersionsStream) error
	HeadVersion(context.Context, *HeadVersionRequest, *HeadVersionResponse) error
}

func RegisterNodeVersionerHandler(s server.Server, hdlr NodeVersionerHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeVersioner{hdlr}, opts...))
}

type NodeVersioner struct {
	NodeVersionerHandler
}

func (h *NodeVersioner) CreateVersion(ctx context.Context, in *CreateVersionRequest, out *CreateVersionResponse) error {
	return h.NodeVersionerHandler.CreateVersion(ctx, in, out)
}

func (h *NodeVersioner) StoreVersion(ctx context.Context, in *StoreVersionRequest, out *StoreVersionResponse) error {
	return h.NodeVersionerHandler.StoreVersion(ctx, in, out)
}

func (h *NodeVersioner) ListVersions(ctx context.Context, stream server.Streamer) error {
	m := new(ListVersionsRequest)
	if err := stream.Recv(m); err != nil {
		return err
	}
	return h.NodeVersionerHandler.ListVersions(ctx, m, &nodeVersionerListVersionsStream{stream})
}

type NodeVersioner_ListVersionsStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*ListVersionsResponse) error
}

type nodeVersionerListVersionsStream struct {
	stream server.Streamer
}

func (x *nodeVersionerListVersionsStream) Close() error {
	return x.stream.Close()
}

func (x *nodeVersionerListVersionsStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeVersionerListVersionsStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeVersionerListVersionsStream) Send(m *ListVersionsResponse) error {
	return x.stream.Send(m)
}

func (h *NodeVersioner) HeadVersion(ctx context.Context, in *HeadVersionRequest, out *HeadVersionResponse) error {
	return h.NodeVersionerHandler.HeadVersion(ctx, in, out)
}

// Client API for FileKeyManager service

type FileKeyManagerClient interface {
	GetEncryptionKey(ctx context.Context, in *GetEncryptionKeyRequest, opts ...client.CallOption) (*GetEncryptionKeyResponse, error)
}

type fileKeyManagerClient struct {
	c           client.Client
	serviceName string
}

func NewFileKeyManagerClient(serviceName string, c client.Client) FileKeyManagerClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &fileKeyManagerClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *fileKeyManagerClient) GetEncryptionKey(ctx context.Context, in *GetEncryptionKeyRequest, opts ...client.CallOption) (*GetEncryptionKeyResponse, error) {
	req := c.c.NewRequest(c.serviceName, "FileKeyManager.GetEncryptionKey", in)
	out := new(GetEncryptionKeyResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for FileKeyManager service

type FileKeyManagerHandler interface {
	GetEncryptionKey(context.Context, *GetEncryptionKeyRequest, *GetEncryptionKeyResponse) error
}

func RegisterFileKeyManagerHandler(s server.Server, hdlr FileKeyManagerHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&FileKeyManager{hdlr}, opts...))
}

type FileKeyManager struct {
	FileKeyManagerHandler
}

func (h *FileKeyManager) GetEncryptionKey(ctx context.Context, in *GetEncryptionKeyRequest, out *GetEncryptionKeyResponse) error {
	return h.FileKeyManagerHandler.GetEncryptionKey(ctx, in, out)
}

func init() { proto.RegisterFile("tree.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1486 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0x4f, 0x73, 0x1b, 0xc5,
	0x12, 0xcf, 0x4a, 0xb2, 0xac, 0x6d, 0x39, 0xb2, 0x3c, 0x76, 0x92, 0x8d, 0xde, 0x7b, 0x79, 0x7e,
	0x7b, 0x48, 0xf9, 0xa5, 0x28, 0x97, 0x23, 0x17, 0x84, 0x02, 0x0e, 0x51, 0xa4, 0x75, 0x62, 0x22,
	0xcb, 0x66, 0x24, 0x27, 0x07, 0x8a, 0x82, 0x45, 0x6a, 0xdb, 0x5b, 0x58, 0xbb, 0x62, 0x76, 0x64,
	0x2c, 0x2e, 0x14, 0x57, 0xaa, 0xf8, 0x22, 0xdc, 0xf9, 0x0a, 0x7c, 0x01, 0x0e, 0x7c, 0x05, 0xee,
	0x7c, 0x01, 0x6a, 0xfe, 0xed, 0xae, 0xfe, 0x84, 0x58, 0x95, 0x8b, 0x6b, 0xba, 0x7f, 0xd3, 0x3d,
	0x3d, 0xdd, 0xd3, 0xbd, 0x3f, 0x19, 0x80, 0x33, 0xc4, 0xdd, 0x11, 0x8b, 0x78, 0x44, 0x0a, 0x62,
	0xed, 0x3e, 0x86, 0x75, 0x8a, 0xfe, 0xa0, 0x13, 0x0d, 0x90, 0xe2, 0xb7, 0x63, 0x8c, 0x39, 0x79,
	0x00, 0x85, 0x30, 0x1a, 0xa0, 0x63, 0x6d, 0x5b, 0x3b, 0xe5, 0x3a, 0xec, 0x4a, 0x1b, 0xb9, 0x41,
	0xea, 0xdd, 0x36, 0x54, 0x53, 0x93, 0x78, 0x14, 0x85, 0x31, 0x12, 0x07, 0x56, 0xe3, 0x71, 0xbf,
	0x8f, 0x71, 0x2c, 0xcd, 0x4a, 0xd4, 0x88, 0x89, 0xb7, 0xdc, 0x1b, 0xbc, 0xfd, 0x69, 0x41, 0xb5,
	0x1d, 0xc4, 0x5c, 0xa8, 0xe2, 0x1b, 0x86, 0x40, 0xfe, 0x0d, 0x36, 0xc3, 0xfe, 0x98, 0xc5, 0xc1,
	0x95, 0xf2, 0x5c, 0xa2, 0xa9, 0x42, 0xa0, 0x7e, 0xd8, 0xc7, 0x98, 0x47, 0x2c, 0x76, 0xf2, 0x0a,
	0x4d, 0x14, 0xa4, 0x06, 0xa5, 0x2b, 0x64, 0x71, 0x10, 0x85, 0xb1, 0xb3, 0x2a, 0xc1, 0x44, 0x26,
	0x5b, 0xb0, 0x72, 0x19, 0x0c, 0x03, 0xee, 0x14, 0xb6, 0xad, 0x9d, 0x3c, 0x55, 0x02, 0xb9, 0x0b,
	0xc5, 0xe8, 0xec, 0x2c, 0x46, 0xee, 0xac, 0x48, 0xb5, 0x96, 0xc8, 0x2e, 0xc0, 0x41, 0x70, 0xc9,
	0x91, 0xf5, 0x26, 0x23, 0x74, 0x8a, 0xdb, 0xd6, 0x4e, 0xa5, 0x5e, 0x49, 0x63, 0x15, 0x5a, 0x9a,
	0xd9, 0xe1, 0xee, 0xc3, 0x46, 0xe6, 0xa6, 0x3a, 0x73, 0x6f, 0xcb, 0xf6, 0xe7, 0xb0, 0xd1, 0x64,
	0xe8, 0x73, 0x5c, 0xa2, 0x44, 0xe4, 0x21, 0x54, 0xc6, 0xa3, 0x81, 0xcf, 0xf1, 0xf0, 0xcc, 0xbb,
	0x0e, 0x62, 0x1e, 0xeb, 0x24, 0xcd, 0x68, 0xdd, 0x0e, 0x90, 0xac, 0xf3, 0x77, 0x2e, 0xe6, 0x31,
	0x6c, 0x9c, 0xca, 0x13, 0x66, 0x82, 0x3d, 0x63, 0xd1, 0x70, 0x51, 0xb0, 0x42, 0x4f, 0x6a, 0x90,
	0xe3, 0xd1, 0x02, 0x97, 0x39, 0x1e, 0x89, 0x00, 0xb3, 0x0e, 0xdf, 0x39, 0xc0, 0x7d, 0xd8, 0x68,
	0xe1, 0x25, 0x2e, 0x95, 0x4d, 0x77, 0x17, 0x48, 0xd6, 0xe8, 0x6d, 0x41, 0xb8, 0x75, 0xa8, 0xbe,
	0xf6, 0x79, 0xff, 0x62, 0x99, 0x33, 0xf6, 0x61, 0x23, 0x63, 0x73, 0xc3, 0xb7, 0xf1, 0x93, 0x05,
	0xb7, 0xbb, 0xe8, 0xb3, 0xfe, 0x85, 0x39, 0xe6, 0x7f, 0xb0, 0xf2, 0xd9, 0x18, 0xd9, 0x44, 0x9b,
	0x94, 0x95, 0x89, 0x54, 0x51, 0x85, 0x10, 0x02, 0x85, 0x6e, 0xf0, 0xbd, 0x4a, 0xd1, 0x0a, 0x95,
	0x6b, 0xa1, 0x3b, 0x10, 0x25, 0xca, 0x2b, 0x9d, 0x58, 0x8b, 0xfb, 0xb5, 0x90, 0xfb, 0xc1, 0x65,
	0x2c, 0xbb, 0xa1, 0x44, 0x8d, 0x28, 0xba, 0xe4, 0xc0, 0xef, 0xeb, 0x76, 0xb0, 0xa9, 0x12, 0xdc,
	0x3d, 0xa8, 0x98, 0x58, 0x6e, 0x18, 0xfe, 0x07, 0xb0, 0xa5, 0x5e, 0xdf, 0x2b, 0xd5, 0x7f, 0x37,
	0xcd, 0xd5, 0x33, 0xb8, 0x33, 0x63, 0xa7, 0x0f, 0xfc, 0x3f, 0xac, 0xea, 0x56, 0xd6, 0xb6, 0xeb,
	0xca, 0xb6, 0x79, 0xe1, 0x87, 0xe7, 0xd8, 0x8e, 0xce, 0xa9, 0xc1, 0xdd, 0xf7, 0x61, 0x53, 0xf4,
	0xa2, 0xf6, 0x70, 0xd3, 0xc1, 0xe3, 0x36, 0x60, 0x6b, 0xda, 0x6c, 0xf9, 0x93, 0x29, 0x90, 0x17,
	0xe8, 0x0f, 0x96, 0xbb, 0xb3, 0x98, 0x69, 0xda, 0xe2, 0x70, 0x20, 0x4b, 0x67, 0xd3, 0x54, 0xe1,
	0x3e, 0x85, 0xcd, 0x29, 0x9f, 0xcb, 0x47, 0xf5, 0x15, 0x6c, 0x76, 0x79, 0xc4, 0x96, 0x2c, 0x45,
	0xf6, 0x84, 0xdc, 0x5b, 0x4e, 0xd8, 0x83, 0xad, 0xe9, 0x13, 0xd2, 0x3e, 0xea, 0x4e, 0xf7, 0x91,
	0x16, 0xdd, 0xdf, 0x72, 0x50, 0x10, 0x67, 0x89, 0xe7, 0x79, 0x3a, 0x0e, 0x06, 0x12, 0xb7, 0xa9,
	0x5c, 0x0b, 0xdd, 0x89, 0xcf, 0x2f, 0x74, 0x2e, 0xe4, 0x9a, 0xb8, 0x50, 0xe0, 0x62, 0x14, 0xe7,
	0x17, 0x8e, 0x62, 0x89, 0x25, 0xcf, 0x5f, 0x4d, 0x78, 0xf5, 0xfc, 0xb7, 0x60, 0xe5, 0xa8, 0x17,
	0x0c, 0x51, 0xcf, 0x77, 0x25, 0x88, 0x9d, 0x47, 0xe2, 0xee, 0x45, 0xd5, 0x14, 0x47, 0x3a, 0x12,
	0x8f, 0xfb, 0xe7, 0xf2, 0xc3, 0x61, 0x53, 0xb9, 0x16, 0x39, 0x68, 0x46, 0xc3, 0x61, 0xc0, 0x63,
	0xc7, 0xde, 0xce, 0x2f, 0xcc, 0x81, 0xc6, 0xc9, 0x13, 0xb0, 0x8f, 0x90, 0xfb, 0x32, 0x0f, 0x4e,
	0x49, 0x6e, 0xbe, 0x9f, 0x46, 0xb9, 0x9b, 0x60, 0x5e, 0xc8, 0xd9, 0x84, 0xa6, 0x7b, 0x6b, 0x9f,
	0x40, 0x65, 0x1a, 0x24, 0x55, 0xc8, 0x7f, 0x83, 0x13, 0x9d, 0x12, 0xb1, 0x14, 0xb7, 0xb8, 0xf2,
	0x2f, 0xc7, 0xa8, 0x53, 0xa2, 0x84, 0x8f, 0x72, 0x1f, 0x5a, 0xee, 0x0f, 0x60, 0x27, 0xc1, 0x2c,
	0x4c, 0xe6, 0x36, 0x94, 0x5b, 0x18, 0xf7, 0x59, 0x30, 0xe2, 0xa6, 0x94, 0x36, 0xcd, 0xaa, 0xd2,
	0x14, 0xe5, 0x67, 0x52, 0x34, 0x97, 0x4c, 0x02, 0x85, 0x96, 0xcf, 0x7d, 0x99, 0xcb, 0x35, 0x2a,
	0xd7, 0xee, 0xef, 0x39, 0x3d, 0x97, 0xc8, 0x03, 0x00, 0x51, 0xaa, 0x13, 0x86, 0x67, 0xc1, 0xb5,
	0x63, 0x6d, 0xe7, 0x77, 0x6c, 0x9a, 0xd1, 0x88, 0xd7, 0x70, 0x14, 0x84, 0xc9, 0x80, 0xca, 0x53,
	0x23, 0x4a, 0xc4, 0xbf, 0x96, 0x48, 0x5e, 0x23, 0x4a, 0xd4, 0x36, 0x2d, 0x9f, 0x9b, 0x40, 0x8c,
	0xa8, 0x6d, 0x24, 0xb2, 0x92, 0xd8, 0x48, 0xc4, 0x85, 0xc2, 0x3f, 0x7c, 0xb5, 0x25, 0x26, 0x98,
	0xc2, 0x41, 0x70, 0x89, 0x1d, 0x7f, 0x88, 0xba, 0xe0, 0x89, 0x2c, 0x3c, 0x37, 0xa3, 0x90, 0x63,
	0xc8, 0x9d, 0x92, 0x84, 0x8c, 0x28, 0x6e, 0x78, 0xc0, 0x10, 0xbb, 0x9c, 0x05, 0xe1, 0xb9, 0x63,
	0x4b, 0x30, 0xa3, 0x11, 0x9d, 0xec, 0x5d, 0x73, 0x0c, 0x65, 0xd3, 0x80, 0xea, 0xe4, 0x44, 0x41,
	0x1e, 0x41, 0xe9, 0x39, 0x46, 0x6a, 0x86, 0x97, 0x65, 0x47, 0xe9, 0xd8, 0x8c, 0x96, 0x26, 0xb8,
	0xfb, 0x8b, 0x95, 0x6e, 0x26, 0x0f, 0xa1, 0xd8, 0xc4, 0x90, 0x23, 0xd3, 0xbd, 0x9a, 0x9a, 0x9d,
	0x44, 0x41, 0xc8, 0xa9, 0x46, 0xc5, 0xa5, 0x5a, 0x41, 0xcc, 0x05, 0x1f, 0xd2, 0x75, 0x4e, 0x64,
	0xb2, 0x03, 0xab, 0xbd, 0x68, 0xd4, 0xc6, 0x33, 0x2e, 0x53, 0x3c, 0xef, 0xc4, 0xc0, 0x64, 0x0f,
	0xca, 0xcf, 0x22, 0xce, 0xa3, 0x21, 0x0d, 0xce, 0x2f, 0x14, 0x5d, 0x9a, 0xdf, 0x9d, 0xdd, 0xe2,
	0xee, 0xca, 0x58, 0x25, 0x20, 0xde, 0xee, 0xa5, 0xcf, 0x65, 0xa0, 0x16, 0x15, 0x4b, 0xa9, 0xd1,
	0x0f, 0x4f, 0x68, 0xa2, 0xd0, 0xfd, 0xcb, 0x82, 0x75, 0x51, 0x0f, 0xf5, 0x70, 0xbd, 0x2b, 0x91,
	0xda, 0x7d, 0x5d, 0x34, 0x4b, 0x16, 0xed, 0xbf, 0x69, 0xd1, 0x32, 0x9b, 0x76, 0xe5, 0xdf, 0x4c,
	0x15, 0x5d, 0x28, 0x76, 0xa3, 0x31, 0xeb, 0x2f, 0x22, 0x05, 0x1a, 0x11, 0x7b, 0x7a, 0x3e, 0x3b,
	0x47, 0x73, 0xef, 0xa9, 0x3d, 0x0a, 0x71, 0xfb, 0x60, 0x27, 0xae, 0x09, 0x40, 0xb1, 0x49, 0xbd,
	0x46, 0xcf, 0xab, 0xde, 0x22, 0x25, 0x28, 0x50, 0xaf, 0xd1, 0xaa, 0x5a, 0x64, 0x1d, 0xca, 0xa7,
	0x27, 0xad, 0x46, 0xcf, 0xfb, 0xf2, 0xa4, 0xd1, 0x7b, 0x51, 0xcd, 0x11, 0x02, 0x15, 0xad, 0x68,
	0x1e, 0x77, 0x7a, 0x5e, 0xa7, 0x57, 0xcd, 0x67, 0x36, 0x1d, 0x79, 0xbd, 0x46, 0xb5, 0x20, 0x7c,
	0xb5, 0xbc, 0xb6, 0xd7, 0xf3, 0xaa, 0x2b, 0xee, 0x8f, 0x16, 0xdc, 0x7b, 0x8e, 0xdc, 0x0b, 0xfb,
	0x6c, 0x22, 0x1b, 0xef, 0x25, 0x4e, 0xcc, 0x2c, 0x26, 0x50, 0x18, 0xc7, 0xba, 0xbe, 0x36, 0x95,
	0x6b, 0x51, 0xcd, 0x91, 0x1f, 0xc7, 0xdf, 0x45, 0xcc, 0x7c, 0x15, 0x12, 0x39, 0x99, 0xdd, 0xf9,
	0x37, 0xcc, 0xee, 0xbb, 0x50, 0xec, 0xcb, 0xcf, 0xa8, 0xec, 0x8d, 0x12, 0xd5, 0x92, 0xfb, 0x1e,
	0x38, 0xf3, 0x21, 0xe8, 0x61, 0x9d, 0x99, 0x3a, 0x6b, 0x72, 0xea, 0x3c, 0x7a, 0x0c, 0x25, 0xd3,
	0x36, 0xa4, 0x0c, 0xab, 0xa7, 0x9d, 0x97, 0x9d, 0xe3, 0xd7, 0x1d, 0x95, 0x96, 0xb6, 0xd7, 0x38,
	0xa8, 0x5a, 0xa4, 0x02, 0xd0, 0x3c, 0x6e, 0xb7, 0xbd, 0x66, 0xef, 0xf0, 0xb8, 0x53, 0xcd, 0xd5,
	0x7f, 0xb6, 0x60, 0x4d, 0xd8, 0x9c, 0xb0, 0xe8, 0x2a, 0x18, 0x20, 0x23, 0x1f, 0x43, 0xc9, 0xfc,
	0xa2, 0x20, 0x77, 0x54, 0x9c, 0x33, 0x3f, 0x4a, 0x6a, 0x77, 0x67, 0xd5, 0x2a, 0x20, 0xf7, 0x16,
	0x79, 0x0a, 0x76, 0xc2, 0xaa, 0x89, 0xde, 0x36, 0xfb, 0x83, 0xa2, 0x76, 0x6f, 0x4e, 0x6f, 0xec,
	0xf7, 0xac, 0xfa, 0x17, 0xb0, 0x95, 0x0d, 0xa7, 0xcb, 0x19, 0xfa, 0x43, 0x64, 0xc4, 0x83, 0x8a,
	0x39, 0x4f, 0xe9, 0x96, 0x0e, 0x6e, 0xc7, 0xda, 0xb3, 0xea, 0x7f, 0xe8, 0xeb, 0x52, 0xec, 0x63,
	0x70, 0x85, 0x8c, 0x34, 0x00, 0x52, 0xd6, 0x4d, 0x74, 0x68, 0x73, 0x24, 0xbf, 0xe6, 0xcc, 0x03,
	0xc9, 0xa5, 0x1b, 0x00, 0x29, 0x2f, 0x36, 0x2e, 0xe6, 0xa8, 0xb7, 0x71, 0x31, 0x4f, 0xa1, 0x95,
	0x8b, 0x94, 0xd5, 0x1a, 0x17, 0x73, 0xe4, 0xd8, 0xb8, 0x98, 0x27, 0xc0, 0xee, 0xad, 0xfa, 0x2b,
	0x20, 0x42, 0x23, 0xdb, 0x22, 0x4e, 0xaa, 0xf9, 0x14, 0xec, 0x84, 0xca, 0x9a, 0x82, 0xcc, 0xf2,
	0x61, 0x53, 0x90, 0x39, 0xce, 0x2b, 0x0b, 0xd2, 0x84, 0x92, 0xa2, 0x92, 0xc8, 0xc8, 0x13, 0x28,
	0xaa, 0x35, 0xd9, 0x54, 0x26, 0x53, 0x84, 0xb7, 0xb6, 0x35, 0xad, 0xcc, 0x38, 0xd9, 0x84, 0x0d,
	0x39, 0x1a, 0xd4, 0x58, 0x16, 0xb5, 0x41, 0x36, 0xa3, 0x7c, 0xcd, 0x02, 0x8e, 0xac, 0xfe, 0x6b,
	0x0e, 0x6e, 0x0b, 0xad, 0x66, 0x26, 0xc8, 0xc8, 0xa7, 0x70, 0x7b, 0x8a, 0x61, 0x92, 0x5a, 0xb6,
	0x16, 0xd3, 0x1c, 0xa9, 0xf6, 0xaf, 0x85, 0x58, 0x92, 0xe7, 0xe7, 0xb0, 0x96, 0xe5, 0x3d, 0x44,
	0x7f, 0xf0, 0x17, 0xb0, 0xad, 0x5a, 0x6d, 0x11, 0x94, 0x38, 0x3a, 0x84, 0xb5, 0x2c, 0xf7, 0x34,
	0x8e, 0x16, 0xd0, 0x58, 0xe3, 0x68, 0x11, 0x55, 0x15, 0xb9, 0x21, 0x2d, 0x28, 0x67, 0xf8, 0x22,
	0xd1, 0x35, 0x9e, 0xa7, 0xa5, 0xb5, 0xfb, 0x0b, 0x90, 0xa4, 0xfc, 0x08, 0x15, 0xf1, 0x3d, 0x7c,
	0x89, 0x93, 0x23, 0x3f, 0xf4, 0xcf, 0x91, 0x91, 0x2e, 0x54, 0x67, 0x47, 0x07, 0xf9, 0x8f, 0xf9,
	0x2a, 0x2c, 0x9c, 0x6a, 0xb5, 0x07, 0x6f, 0x82, 0xcd, 0x31, 0x5f, 0x17, 0xe5, 0xff, 0x2b, 0xf6,
	0xff, 0x0e, 0x00, 0x00, 0xff, 0xff, 0xbf, 0x29, 0x4e, 0x08, 0xbd, 0x10, 0x00, 0x00,
}
